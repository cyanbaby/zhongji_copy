# [《JavaScript设计模式与开发实践》 - 曾探](https://github.com/xingbofeng/JavaScript-design-patterns)
* todo《设计模式：可复用面向对象软件的基础》
* todo《设计模式沉思录》
* todo 依赖倒置原则（DIP）
* [文中 symbols 涉及的仓库](https://github.com/lukehoban/es6features)
* [Brendan Eich 布蘭登·艾克](https://zh.wikipedia.org/zh/%E5%B8%83%E8%98%AD%E7%99%BB%C2%B7%E8%89%BE%E5%85%8B)
* todo 《JavaScript 语言精髓与编程实践》
* [剑指offer](https://www.nowcoder.com/ta/coding-interviews)
* [变量简写](https://www.csdn.net/tags/NtTakgwsMDAwMDYtYmxvZwO0O0OO0O0O.html)
## 第一部分 基础知识

### 1 面向对象的 JavaScript
./chapter01
* 1.1 动态类型语言和鸭子类型 2
  * todo 也就是关注 HAS-A, 而不是 IS-A。
  * 利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。
  *  面向接口编程
      ```js
      /* 
      例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就
      可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥
      有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。  
      */
      ```
* 1.2 多态 4
  * 1.2.1 一段“多态”的JavaScript代码
    ```js
    /*
    换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。

    多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与 “可能改变的事物”分离开来。

    动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。
    把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，
    程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说，
    仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。
    */
    ```
  * 1.2.2 对象的多态性
  * 1.2.3 类型检查和多态  todo 看一下Java基础，理解文中Java代码块
  * 1.2.4 使用继承得到多态效果  todo 实现继承和接口继承
  * 1.2.5 JavaScript的多态
    ```js
    // 由此可见，某一种动物能否发出叫声，只取决于它有没有 makeSound 方法，而不取决于它是否是某种类型的对象，
    ```
  * 1.2.6 多态在面向对象程序设计中的作用
    ```js
    /*
    Martin Fowler 在《重构：改善既有代码的设计》里写到： 
       多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，
       其他的一切多态机制都会为你安排妥当。
    换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。
    
        在电影的拍摄现场，当导演喊出“action”时，主角开始背台词，照明师负责打灯
    光，后面的群众演员假装中枪倒地，道具师往镜头里撒上雪花。在得到同一个消息时，
    每个对象都知道自己应该做什么。如果不利用对象的多态性，而是用面向过程的方式来
    编写这一段代码，那么相当于在电影开始拍摄之后，导演每次都要走到每个人的面前，
    确认它们的职业分工（类型），然后告诉他们要做什么。如果映射到程序中，那么程序
    中将充斥着条件分支语句。 
    */
    ```
  * 1.2.7 设计模式与多态

* 1.3 封装 12
    ```js 
    /*
      封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。
      这一节将讨论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。
    */
    ```
  * 1.3.1 封装数据
    ```js
    /* 
      在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、public、
      protected 等关键字来提供不同的访问权限。

      但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，
      而且只能模拟出 public 和 private 这两种封装性
    */
    ```
  * 1.3.2 封装实现
    ```js
    /*
    封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是
    隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。

    从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的。
    对象对它自己的行为负责。其他对象或者用户都不关心它的内部实现。
    封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。
    当我们修改一个对象时，可以随意地修改它的内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。
    */
    ```
  * 1.3.3 封装类型
    ```js
    /*
    当然在 JavaScript 中，并没有对抽象类和接口的支持。JavaScript 本身也是一门类型模糊的语
    言。在封装类型方面，JavaScript 没有能力，也没有必要做得更多。对于 JavaScript 的设计模式实
    现来说，不区分类型是一种失色，也可以说是一种解脱。
    */
    ```
  * 1.3.4 封装变化
    ```js
    /*
    从设计模式的角度出发，封装在更重要的层面体现为封装变化。
    《设计模式》一书曾提到如下文字：
      “考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。
      它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况
      下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。

    这段文字即是《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了 23种设计模式。
    从意图上区分，这 23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。
    拿创建型模式来说，要创建一个对象，是一种抽象行为，而具体创建什么对象则是可以变化的，创建型模式的目的就是封装创建对象的变化。
    而结构型模式封装的是对象之间的组合关系。
    行为型模式封装的是对象的行为变化。 

    通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，
    我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。
    这可以最大程度地保证程序的稳定性和可扩展性。

    从《设计模式》副标题“可复用面向对象软件的基础”可以知道，这本书理应教我们如何编写可复用的面向对象程序。
    这本书把大多数笔墨都放在如何封装变化上面，这跟编写可复用的面向对象程序是不矛盾的。
    当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。
    */
    ```
* 1.4 原型模式和基于原型继承的 JavaScript 对象系统 14 
  ```js
  /*
  在 Brendan Eich 为 JavaScript 设计面向对象系统时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。
  之所以选择基于原型的面向对象系统，并不是因为时间匆忙，它设计起来相对简单，
  而是因为从一开始 Brendan Eich 就没有打算在 JavaScript 中加入类的概念。 

  在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。
  而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，
  一个对象是通过克隆另外一个对象所得到的。就像电影《第六日》一样，通过克隆可以创造另外
   一个一模一样的人，而且本体和克隆体看不出任何区别。

  原型模式不单是一种设计模式，也被称为一种编程泛型。
  */
  ```
  * 1.4.1 使用克隆的原型模式
    ```js
    /*
    从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，
    一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，
    我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。

    既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一
    模一样的对象，就可以使用原型模式。
    */
    ```
     * 1.4.2 克隆是创建对象的手段
    ```js
    /*
    通过上一节的代码，我们看到了如何通过原型模式来克隆出一个一模一样的对象。但原型模
    式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类
    型的对象，克隆只是创建这个对象的过程和手段。


    原型模式提供了另外一种创建对象的方式，通过克隆对象，我们就不用再关心对象的具体类
    型名字。这就像一个仙女要送给三岁小女孩生日礼物，虽然小女孩可能还不知道飞机或者船怎么
    说，但她可以指着商店橱柜里的飞机模型说“我要这个”。

    当然在 JavaScript 这种类型模糊的语言中，创建对象非常容易，也不存在类型耦合的问题。
    从设计模式的角度来讲，原型模式的意义并不算大 。但 JavaScript 本身是一门基于原型的面向对
    象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型也许更合适。 
    */
    ```
  * 1.4.3 体验Io语言
  * 1.4.4 原型编程范型的一些规则
    * 所有的数据都是对象。
    * 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
    * 对象会记住它的原型。
    * 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。
  * 1.4.5 JavaScript中的原型继承
    ```js
    /*
    JavaScript 也同样遵守这些原型编程的基本规则。
      所有的数据都是对象。
      要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
      对象会记住它的原型。
      如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。
    */
    ```
  * 1.4.6 原型继承的未来
    ```js
    // 设计模式在很多时候其实都体现了语言的不足之处。Peter Norvig 曾说，设计模式是对语言
    // 不足的补充，如果要使用设计模式，不如去找一门更好的语言。这句话非常正确。不过，作为
    // Web 前端开发者，相信 JavaScript 在未来很长一段时间内都是唯一的选择。
    ```
  * 1.4.6 小结
### 2 this、call 和 apply
./chapter02
* 2.1 this 24
  ```js
  // 跟别的语言大相径庭的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在
  // 运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。

  // 除去不常用的 with 和 eval 的情况，具体到实际应用中，this 的指向大致可以分为以下 4 种。
  //    作为对象的方法调用。
  //    作为普通函数调用。
  //    构造器调用。
  //    Function.prototype.call 或 Function.prototype.apply 调用。
  ```
  * 2.1.1 this的指向
  * 2.1.2 丢失的this
* 2.2 call 和 apply 29 
  ```js
  // ECAMScript 3给Function的原型定义了两个方法，它们是Function.prototype.call和Function.
  // prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤
  // 为有用。在 JavaScript 版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方
  // 法，是我们真正成为一名 JavaScript 程序员的重要一步。
  ```
  * 2.2.1 call和apply的区别
  * 2.2.2 call和apply的用途
    1. 改变 this 指向
    2. todo bind
    3. 借用其他对象的方法


### 3 闭包和高阶函数
./chapter03
* 3.1 闭包 35
  * todo 闭包相关笔试题
  * 3.1.1 变量的作用域
  * 3.1.2 变量的生存周期
    ```js
    // 无论点击哪个 div，最后弹出的结果都是 5。用作用域解决，其实渡一变量提升课程说过函数参数的意义。如通函数内部var一个参数变量
    ```
  * 3.1.3 闭包的更多作用
    1. 封装变量
    2. 延续局部变量的寿命
  * 3.1.4 闭包和面向对象设计
  * 3.1.5 用闭包实现命令模式
  * 3.1.6 闭包与内存管理
    ```js
    // 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境
    // 中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时
    // 销毁。

    // 使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要
    // 使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并
    // 不能说成是内存泄露。

    // 如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。



    // 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作
    // 用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也
    // 并非 JavaScript 的问题。在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象
    // 的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。


    // 在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用
    // 造成的内存泄露在本质上也不是闭包造成的。
    // 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null即可。
    // 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运
    // 行时，就会删除这些值并回收它们占用的内存。
    ```
* 3.2 高阶函数 44
  ```js
  // 高阶函数是指至少满足下列条件之一的函数。
  //    函数可以作为参数被传递；
  //    函数可以作为返回值输出。
  ```
  * 3.2.1 函数作为参数传递
    1. 回调函数
    2. Array.prototype.sort
    3. ..
  * 3.2.2 函数作为返回值输出
    1. 判断数据的类型
    2. getSingle
  * 3.2.3 高阶函数实现AOP
  ```js
  //   AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些
  // 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，
  // 再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的
  // 纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。

  // 在 Java 语言中，可以通过反射和动态代理机制来实现 AOP 技术。而在 JavaScript 这种动态
  // 语言中，AOP 的实现更加简单，这是 JavaScript 与生俱来的能力。
  ```
  * 3.2.4 高阶函数的其他应用
    1. currying
    2. uncurrying
    3. 函数节流
    4. 分时函数
    5. 惰性加载函数
* 3.3 小结 58 
```js
// 在进入设计模式的学习之前，本章挑选了闭包和高阶函数来进行讲解。这是因为在 JavaScript
// 开发中，闭包和高阶函数的应用极多。就设计模式而言，因为 JavaScript 这门语言的自身特点，
// 许多设计模式在 JavaScript 之中的实现跟在一些传统面向对象语言中的实现相差很大。在
// JavaScript 中，很多设计模式都是通过闭包和高阶函数实现的。这并不奇怪，相对于模式的实现
// 过程，我们更关注的是模式可以帮助我们完成什么。
```
## 第二部分 设计模式 
```js
// 现在，我们终于步入了设计模式学习的殿堂。
// 在将函数作为一等对象的语言中，有许多需要利用对象多态性的设计模式，比如命令模式、
// 策略模式等，这些模式的结构与传统面向对象语言的结构大相径庭，实际上已经融入到了语言之
// 中，我们可能经常使用它们，只是不知道它们的名字而已。 
// 第二部分并没有全部涵盖 GoF 所提出的 23 种设计模式，而是选择了在 JavaScript 开发中更
// 常见的 14 种设计模式。
```
### 4 单例模式
./chapter04
```js
// 单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

// 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏
// 览器中的 window 对象等。在 JavaScript 开发中，单例模式的用途同样非常广泛。试想一下，当我
// 们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少
// 次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。
```
* 4.1 实现单例模式 60
* 4.2 透明的单例模式 61
* 4.3 用代理实现单例模式 62
* 4.4 JavaScript 中的单例模式 63
  * 单例模式的核心是确保只有一个实例，并提供全局访问。
  * 全局变量污染
* 4.5 惰性单例 65
  * 案例好好总结一下单例精髓！
* 4.6 通用的惰性单例 68
* 4.7 小结 70
```js
// 单例模式是我们学习的第一个模式，我们先学习了传统的单例模式实现，也了解到因为语言
// 的差异性，有更适合的方法在 JavaScript 中创建单例。这一章还提到了代理模式和单一职责原则，
// 后面的章节会对它们进行更详细的讲解。
// 在 getSinge 函数中，实际上也提到了闭包和高阶函数的概念。单例模式是一种简单但非常实
// 用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的
// 是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模
// 式的威力。
```


### 5 策略模式
```js
// 俗话说，条条大路通罗马。在美剧《越狱》中，主角 Michael Scofield 就设计了两条越狱的
// 道路。这两条道路都可以到达靠近监狱外墙的医务室。
// 同样，在现实中，很多时候也有多种途径到达同一个目的地。比如我们要去某个地方旅游，
// 可以根据具体的实际情况来选择出行的线路。 
//  如果没有时间但是不在乎钱，可以选择坐飞机。
//  如果没有钱，可以选择坐大巴或者火车。
//  如果再穷一点，可以选择骑自行车。

// 在程序设计中，我们也常常遇到类似的情况，要实现某一个功能有多种方案可以选择。比如
// 一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。
// 这些算法灵活多样，而且可以随意互相替换。这种解决方案就是本章将要介绍的策略模式。

// 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
```
* 5.1 使用策略模式计算奖金 72
* 5.2 JavaScript 版本的策略模式 75
* 5.3 多态在策略模式中的体现 76
  ```js
  // 通过使用策略模式重构代码， 我们消除了原程序中大片的条件分支语句。 所有跟计算奖金有
  // 关的逻辑不再放在 Context 中，而是分布在各个策略对象中。Context 并没有计算奖金的能力， 而
  // 是把这个职责委托给了某个策略对象。
  
  // 每个策略对象负责的算法已被各自封装在对象内部。 当我
  // 们对这些策略对象发出“ 计算奖金” 的请求时， 它们会返回各自不同的计算结果， 这正是对象多
  // 态性的体现， 也是“ 它们可以相互替换” 的目的。替换 Context 中当前保存的策略对象， 便能执
  // 行不同的算法来得到我们想要的结果。
  ```
  * 5.4 使用策略模式实现缓动动画 76
  * todo Flash和HTML5的游戏、动画区别？
  * todo CSS3动画类型，vue动画，react动画，angular动画
  * todo 缓动公式，动画的其他缓动算法（Tween.js  =>  https://cloud.tencent.com/developer/article/1644054）
  * todo Date对象
    * new Date() 转时间戳, 互转
    * moment
  * todo DOM,BOM 相关面试
  * todo for in循环能遍历对象那些属性？
  * todo opacity里面的元素也会透明化？
* 5.5 更广义的“算法” 80
* 5.6 表单校验 80
  * 至此要把之前的策略模式重学一下，好好领悟！
* 5.7 策略模式的优缺点 86
* 5.8 一等函数对象与策略模式 86
  * 至此要把之前的策略模式重学一下，好好领悟！
* 5.9 小结 87
```js
// 本章我们既提供了接近传统面向对象语言的策略模式实现，也提供了更适合 JavaScript 语言
// 的策略模式版本。在 JavaScript 语言的策略模式中，策略类往往被函数所代替，这时策略模式就
// 成为一种“隐形”的模式。尽管这样，从头到尾地了解策略模式，不仅可以让我们对该模式有更
// 加透彻的了解，也可以使我们明白使用函数的好处。
```

### 6 代理模式
* 6.1 第一个例子——小明追 MM 的故事 88
* 6.2 保护代理和虚拟代理 91
* 6.3 虚拟代理实现图片预加载 91
* 6.4 代理的意义 93
* 6.5 代理和本体接口的一致性 94
* 6.6 虚拟代理合并 HTTP 请求 95
* 6.7 虚拟代理在惰性加载中的应用 97
* 6.8 缓存代理 99
* 6.9 用高阶函数动态创建代理 100
* 6.10 其他代理模式 101
* 6.11 小结 102 

### 7 迭代器模式
* 7.1 jQuery 中的迭代器 103
* 7.2 实现自己的迭代器 104
* 7.3 内部迭代器和外部迭代器 104
* 7.4 迭代类数组对象和字面量对象 106
* 7.5 倒序迭代器 106
* 7.6 中止迭代器 107
* 7.7 迭代器模式的应用举例 107
* 7.8 小结 109


### 8 发布—订阅模式
* 8.1 现实中的发布—订阅模式 110
* 8.2 发布—订阅模式的作用 110
* 8.3 DOM 事件 111
* 8.4 自定义事件 112
* 8.5 发布—订阅模式的通用实现 113
* 8.6 取消订阅的事件 115
* 8.7 真实的例子——网站登录 115
* 8.8 全局的发布—订阅对象 117
* 8.9 模块间通信 119
* 8.10 必须先订阅再发布吗 120
* 8.11 全局事件的命名冲突 121
* 8.12 JavaScript 实现发布—订阅模式的便利性 124
* 8.13 小结 124 


### 9 命令模式
* 9.1 命令模式的用途 125
* 9.2 命令模式的例子——菜单程序 126
* 9.3 JavaScript 中的命令模式 128
* 9.4 撤销命令 130
* 9.5 撤消和重做 132
* 9.6 命令队列 134
* 9.7 宏命令 134
* 9.8 智能命令与傻瓜命令 135
* 9.9 小结 136

### 10 组合模式
* 10.1 回顾宏命令 138
* 10.2 组合模式的用途 139
* 10.3 请求在树中传递的过程 139
* 10.4 更强大的宏命令 140
* 10.5 抽象类在组合模式中的作用 143
* 10.6 透明性带来的安全问题 144
* 10.7 组合模式的例子——扫描文件夹 145
* 10.8 一些值得注意的地方 147
* 10.9 引用父对象 148
* 10.10 何时使用组合模式 150
* 10.11 小结 150 


### 11 模板方法模式
* 11.1 模板方法模式的定义和组成 151
* 11.2 第一个例子——Coffee or Tea 151
* 11.3 抽象类 156
* 11.4 模板方法模式的使用场景 159
* 11.5 钩子方法 160
* 11.6 好莱坞原则 162
* 11.7 真的需要“继承”吗 162
* 11.8 小结 164 


### 12 享元模式
* 12.1 初识享元模式 165
* 12.2 内部状态与外部状态 166
* 12.3 享元模式的通用结构 167
* 12.4 文件上传的例子 167
* 12.5 享元模式的适用性 173
* 12.6 再谈内部状态和外部状态 173
* 12.7 对象池 175
* 12.8 小结 178

### 13 职责链模式
* 13.1 现实中的职责链模式 179
* 13.2 实际开发中的职责链模式 180
* 13.3 用职责链模式重构代码 181
* 13.4 灵活可拆分的职责链节点 183
* 13.5 异步的职责链 184
* 13.6 职责链模式的优缺点 185
* 13.7 用 AOP 实现职责链 186
* 13.8 用职责链模式获取文件上传对象 187
* 13.9 小结 188

### 14 中介者模式
* 14.1 现实中的中介者 190
* 14.2 中介者模式的例子——泡泡堂游戏 191
* 14.3 中介者模式的例子——购买商品 199
* 14.4 小结 207

### 15 装饰者模式
* 15.1 模拟传统面向对象语言的装饰者模式 210
* 15.2 装饰者也是包装器 211
* 15.3 回到 JavaScript 的装饰者 212
* 15.4 装饰函数 212
* 15.5 用 AOP 装饰函数 214
* 15.6 AOP 的应用实例 216
* 15.7 装饰者模式和代理模式 222
* 15.8 小结 223

### 16 状态模式
* 16.1 初识状态模式 224
* 16.2 状态模式的定义 230
* 16.3 状态模式的通用结构 230
* 16.4 缺少抽象类的变通方式 231
* 16.5 另一个状态模式示例——文件上传 232
* 16.6 状态模式的优缺点 241
* 16.7 状态模式中的性能优化点 241
* 16.8 状态模式和策略模式的关系 241
* 16.9 JavaScript 版本的状态机 242
* 16.10 表驱动的有限状态机 244
* 16.11 实际项目中的其他状态机 245
* 16.12 小结 245

### 17 适配器模式
* 17.1 现实中的适配器 246
* 17.2 适配器模式的应用 247
* 17.3 小结 250


## 第三部分 设计原则和编程技巧

### 18 单一职责原则
* 18.1 设计模式中的 SRP 原则 252
* 18.2 何时应该分离职责 256
* 18.3 违反 SRP 原则 256
* 18.4 SRP 原则的优缺点 257

### 19 最少知识原则
* 19.1 减少对象之间的联系 258
* 19.2 设计模式中的 LKP 原则 259
* 19.3 封装在 LKP 原则中的体现 261 


### 20 开放—封闭原则
* 20.1 扩展 window.onload 函数 263
* 20.2 开放和封闭 264
* 20.3 用对象的多态性消除条件分支 265
* 20.4 找出变化的地方 266
* 20.5 设计模式中的开放—封闭原则 268
* 20.6 开放—封闭原则的相对性 270
* 20.7 接受第一次愚弄 270 


### 21 接口和面向接口编程
* 21.1 回到 Java 的抽象类 271
* 21.2 interface 276
* 21.3 JavaScript 语言是否需要抽象类和 interface 275
* 21.4 用鸭子类型进行接口检查 277
* 21.5 用 TypeScript 编写基于 interface 的命令模式 278
* 22.1 提炼函数 282


### 22 代码重构
* 22.2 合并重复的条件片段 283
* 22.3 把条件分支语句提炼成函数 284
* 22.4 合理使用循环 285
* 22.5 提前让函数退出代替嵌套条件分支 285
* 22.6 传递对象参数代替过长的参数列表 286
* 22.7 尽量减少参数数量 287
* 22.8 少用三目运算符 288
* 22.9 合理使用链式调用 288
* 22.10 分解大型类 289
* 22.11 用 return 退出多重循环 290