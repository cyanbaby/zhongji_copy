# [那些高级/资深的前端是如何回答JavaScript面试题的 （一）](https://juejin.cn/post/6971727286856843295)
文内搜索： 其实与编译还有另一个称呼：执行期上下文
预编译

## [前端0基础入门 + Web百大项目案例 - 渡一](https://www.bilibili.com/video/BV1f4411R7M5?p=13)
0:23:00

### 渡一教育_递归_预编译_上
课堂小练习 => 跳过
  * 写一个函数，功能是告知你所选定的小动画的叫声。
  * 写一个函数，实现加法计数器。
  * 定义一组函数，输入数字，逆转并输出汉字形式。  
  * 写一个函数，实现n的阶乘。
  * 写一个函数，实现斐波那契数列。

JS运行三部曲
  * 语法分析（词法分析，文法分析，——重学前端）
  * 预编译
  * 解释执行

JS是解释型语言: 
  * 解释一句，执行一句。其实还没有这么直观
  * JS预语法分析和编译之后才会解释一行执行一行

JS函数预编译，四部曲
  1. 创建AO对象  === Activation Object(执行期上下文)
  2. 找形参和变量声明，将变量和形参名作为AO对象的属性名，值为undefined  ==> 这才是真正的变量提升的精髓
  3. 将实参值和形参统一
  4. 在函数体里找函数声明，值赋予函数体  ==> AO有则覆盖，无则添加，变量和函数同名时，函数提升权重大于变量(覆盖)的原因

  查找变量声明 无视if/else 可以提取
  查找函数声明 if/else 是不能提取的


JS全局预编译，三部曲
  * 比函数预编译少了一步：将实参值和形参统一
  * AO 换名 Global Object 
  * GO === window

JS变量声明使用规则
  1. imply global => 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有 
  2. 一切声明的全局变量，全是window的属性（全局对象的属性）

### 渡一教育_递归_预编译_下
chrome/js更新
  * function 课程一年前还能定义在if里面，现在语法不通过了

函数参数规则
  * arguments[0]和形参是映射的，你改我也改，我改你也改
  * 普通类型和引用类型是有区别的《重学前端》

### [作用域_作用域链精解](https://www.bilibili.com/video/BV1f4411R7M5?p=17&spm_id_from=pageDriver)
18:00

函数是一种对象也可以有属性
  * fn.name、fn.prototype、fn[ [scope ] ] 这个隐式属性，不可访问 ..

[ [scope ] ]：
  * [ [scope ] ]指的就是我们所说的作用域，其中存储了运行期上下文的集合。

作用域链：
  * [ [scope ] ]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。
  * [ [scope ] ] 属性()存的值(value) 就是 [ [scope chain] ]
  * [ [scope chain] ] 里面才是存放的  AO,AO,...,GO

运行期上下文：
  * 当函数执行时，会创建一个称为 执行期上下文 的内部对象。
  * 一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。

结合函数参数规则调用函数 产生 AO:
```js
function test (){
  var x = 10
  // ..
}

test() // =>  AO
test() // =>  AO
test() // =>  AO

// AO执行完毕会销毁，结合函数参数规则，传递一个引用类型，这个引用的类型不会随着AO销毁的
```

查找变量：
  * 从作用域链的顶端依次向下查找。补充：在哪个函数里查找变量就上哪个函数的作用域链的顶端向下查找

todo
  * 他的课件截图一下
  * 垃圾回收机制（围绕执行期上下文）